syntax = "proto3";
package nezha.proto;

message Request {
    uint64 sendtime = 1;
    uint32 bound=2;
    uint32 clientid = 3;
    uint32 reqid = 4;
    bytes command=5;
    uint64 proxyid = 6;
    uint32 key = 7;
}

message Reply {
    uint32 clientid = 1;
    uint32 reqid = 2;
    uint32 view = 3;
    uint32 replicaid = 4;
    bytes hash = 5;
    bytes result = 6;
    uint32 replytype = 7;
}

message IndexSync {
    uint32 logidbegin = 1;
    uint32 logidend = 2;
    repeated uint64 deadlines = 3;
    repeated uint64 reqkeys =4;
    uint32 view = 5;
    // crash-vector
    repeated uint32 cv = 6;
}

message AskIndex {
    uint32 logidbegin = 1;
    uint32 logidend = 2;
    uint32 replicaid = 3;
}

message AskReq {
    repeated uint64 missedreqkeys = 1;
    uint32 replicaid = 2;
}

message MissedReq {
    repeated Request reqs = 1;
    uint32 replicaid = 2;
}

message ViewChangeRequest{
    uint32 view = 1;
    uint32 replicaid = 2;
    repeated uint32 cv = 3;
}

message ViewChange {
    uint32 view = 1;
    uint32 replicaid = 2;
    repeated uint32 cv = 3;
    uint32 lastnormalview= 4;
    // In the algo, we should include the logs in the viewchange msg
    // But that is too large. As an implementation optimization, Let's use the following 3 attributes, and later do state transfer to get the necessary entries
    uint32 syncpoint = 5;
    uint32 unsyncedlogbegin= 6;
    uint32 unsyncedlogend = 7;

}

message StartView {
    uint32 view = 1;
    uint32 replicaid = 2;
    repeated uint32 cv = 3;
    uint32 syncpoint = 4;
}

message StateTransferRequest {
    uint32 view = 1;
    uint32 replicaid = 2;
    repeated uint32 logbegin = 3;
    repeated uint32 logend = 4;
}

message StateTransferReply {
    uint32 view = 1;
    uint32 replicaid = 2;
    repeated uint32 cv = 3;
    uint32 logbegin = 4;
    uint32 logend = 5;
    repeated Request reqs = 6;
}